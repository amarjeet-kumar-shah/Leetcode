class Solution {
public:
    // code short rakhne ke liye
    using vi = vector<int>;
    using vvi = vector<vector<int>>;
    using vb = vector<bool>;
    // debugging ke liye
    void printVec(vi& vec,string what){
        cout<<what<<"\n";
        for(int i=0;i<vec.size();i++){
            cout<<"\nfor i= "<<i<<" vec[i] = "<<vec[i];
        }
    }
    void printSet(set<int>& mySet,string what){
        cout<<what<<" size = "<<mySet.size()<<"\n";
        int i=0;
        for(auto it=mySet.begin();it!=mySet.end();it++){
            cout<<"\nfor i= "<<i<<" set[i] = "<<*it;
            i++;
        }
    }
    void printMap(map<int,int>& myMap,string what){
        cout<<what<<" size = "<<myMap.size()<<"\n";
        int i=0;
        for(auto it=myMap.begin();it!=myMap.end();it++){
            cout<<"\n"<<it->first<<" -> "<<it->second;
            i++;
        }
    }
    // DSU ke union and find function
    
    int find_compressed(vi& parent,int x){
        if(parent[x]==x){
            return x;
        }else{
            int ldrx = find_compressed(parent,parent[x]);
            parent[x]=ldrx;
            return ldrx;
        }
    }

    bool union_by_rank(vi& parent,vi& rank,int x,int y){
        int ldrx = find_compressed(parent,x);
        int ldry = find_compressed(parent,y);

        if(ldrx == ldry){
            return false;
        }else{
            if(rank[ldrx]<rank[ldry]){
                parent[ldrx]=ldry;
            }else if(rank[ldrx]>rank[ldry]){
                parent[ldry]=ldrx;
            }else{
                parent[ldry]=ldrx;
                rank[ldrx]++;
            }
            return true;
        }
    }


    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        //parent and rank arrays bana diye sbse pehle
        int n = graph.size();
        vi parent(n),rank(n,0);
        for(int i=0;i<parent.size();i++) parent[i]=i;

        // step 1: union of all the connected vertices in the graph

        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(graph[i][j]==1){
                    union_by_rank(parent,rank,i,j);
                }
            }
        }
        printVec(parent,"parent array");

        // step 2: count the number of vertices in each component in a map
        map<int,int> componentSize;
        for(int i=0;i<n;i++){
            int ldr = find_compressed(parent,parent[i]); // ye find karna jaruri hai nahi toh leader ki jagah parent ki freq increase
            componentSize[ldr]++; //hojayegi, which we dont want, we want freq of leader to increase kyuki parent aur leader 
            // ek hi component mein hai
        }

        printMap(componentSize,"\n\nComponent size ");

        //step 3: we check effectiveness of each one in initial list
        set<int> blackListIndices;
        for(int i=0;i<initial.size();i++){
            for(int j=i;j<initial.size();j++){
                if(j==i) continue;

                int ldri = find_compressed(parent,initial[i]);
                int ldrj = find_compressed(parent,initial[j]);
                if(ldri==ldrj){
                    blackListIndices.insert(i);
                    blackListIndices.insert(j);
                }
                
            }
        }
        printSet(blackListIndices,"\n\nBlack Listed indices");
        int ans=INT_MAX;
        if(blackListIndices.size()==initial.size()){
            return *min_element(initial.begin(),initial.end());
        }else{
            for(int i=0;i<initial.size();i++){
                if(blackListIndices.find(i)==blackListIndices.end()){
                    if(ans==INT_MAX){
                        ans=initial[i];
                    }else{
                        int ldri = find_compressed(parent,initial[i]);
                        int ldrAns = find_compressed(parent,ans);
                        if(componentSize[ldri]>componentSize[ldrAns]){
                            ans = initial[i];
                        }else if(componentSize[ldri]==componentSize[ldrAns]){
                            ans = min(initial[i],ans);
                        }
                    }
                }
            }
            return ans;
        }


        return -100;
        
    
    }
};